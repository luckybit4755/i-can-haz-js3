<HTML>
	<HEAD>
		<TITLE>BxoTest</TITLE>

		<style>
			body {
				font-family: Comic Sans MS, sans;
                background:black;
            }
			div {
				padding-left: 3em;
				color:#FF9;
			}
            canvas {
                width:512px;
                height:512px;
                margin: auto;
                display: block;
                padding-top:66px;
            }
			img {
				display:none;
			}
			input[type="range"] { 
				width:600px;
				display:block;
			}
		</style>

        <script src="../../src/util/Matrix.js"></script>
        <script src="../../src/util/Point.js"></script>
        <script src="../../src/weak/TriangularB6.js"></script>
        <script>

			const EPSILON = 0.00000000001; // blecho!

			// https://raw.githubusercontent.com/luckybit4755/geom/master/cube.geom 
			const CUBE = { vertices: [ [ 1, 1, 1 ] , [-1, 1, 1 ] , [-1,-1, 1 ] , [ 1,-1, 1 ] , [ 1, 1,-1 ] , [-1, 1,-1 ] , [-1,-1,-1 ] , [ 1,-1,-1 ] ], indices:[ [1,5,8,4] ,[2,3,7,6] ,[1,2,6,5] ,[3,4,8,7] ,[4,3,2,1] ,[5,6,7,8] ] };

			const interaction = function( id, cb, smokeless ) {
				var target = document.getElementById( id );
				if ( !target ) return;
				console.log( target );
				target.onclick = target.onchange = target.oninput = function( event ) { 
					if ( /checkbox/i.test( target.type ) ) {
						return cb( target.checked, event ); 
					}
					if ( /color/i.test( target.type ) ) {
						return cb( target.value, event ); 
					}
					if ( /range/i.test( target.type ) ) {
						var v = parseInt( target.value );
						var max = parseInt( target.max );
						var min = parseInt( target.min );
						var diff = 1.0 * ( max - min );
						v = ( v - min ) / diff;
						return cb( v, event, target );
					}
					console.log( target.type );
					return cb( target, event );
				}

				if ( smokeless ) {
					console.log( 'do not smoke test: ' + target );
				} else {
					target.onclick();
				}

				return target;
			};

			const now = function() {
				return new Date().getTime() / 1000.0;
			};

			window.onload = function() {
				const canvas = document.getElementsByTagName( 'canvas' )[ 0 ];
				const info = document.getElementById( 'info' );

				const tb6 = new TriangularB6( canvas );
				const matrix = new Matrix().common();
				
				var time = 0;
				var triangles = 0;
				var begin = now();

				var iteration = 0;

				var angles = [0,0,0];
				var control = [];

				var which = 0;
				const angle_increment = 0.08;

				var spherish = 0;
				var spherish_increment = 0.02;

				const w = parseInt( canvas.width );
				const h = parseInt( canvas.height );

				const w2 = w * 0.5;
				const w3 = w * 0.28;

				var useTextures = true;
				var useDynamicTextures = true;
				var useShading = true;

				var paused = false;

				const handlers = function() {
					interaction( 'texture' ,   function( v ) { tb6.setTexture( null ); useTextures = v } );
					interaction( 'dynamic' ,   function( v ) { tb6.setTexture( null ); useDynamicTextures = v } );
					interaction( 'outlines',   function( v ) { tb6.outline = v } );
					interaction( 'shading',    function( v ) { useShading = v } );
					interaction( 'background', function( v ) { tb6.fillStyle = v } );
					interaction( 'timer',      function( v ) { time = 0; triangles = 0; begin = now(); } );
					interaction( 'alphonzo',   function( v ) { tb6.fillStyle = 'rgba(190,190,255,0.07)' }, true );

					var p2 = Math.PI * 2;

					control.push( interaction( 'a0', function( v,e,t ) { if (t.ignore) return; paused = true; angles[ 0 ] = v * p2 }, true ) );
					control.push( interaction( 'a1', function( v,e,t ) { if (t.ignore) return; paused = true; angles[ 1 ] = v * p2 }, true ) );
					control.push( interaction( 'a2', function( v,e,t ) { if (t.ignore) return; paused = true; angles[ 2 ] = v * p2 }, true ) );

					canvas.onclick = function() { paused = !paused };
				};
				handlers();

				const makeSides = function() {
					var sides = [];

					CUBE.indices.forEach(
						function( indices ) {
							var side = [];
							sides.push( side );
							for ( var i = indices.length - 1 ; i >= 0 ; i-- ) {
								var index = indices[ i ];
								var pt = CUBE.vertices[ index - 1 /* ww! */ ]; 
								side.push( new Point().initArray( pt ) );
							}

							var range = {
								  min:[EPSILON,EPSILON,EPSILON]
								, max:[EPSILON,EPSILON,EPSILON]
								, diff:[EPSILON,EPSILON,EPSILON]
							};

							side.forEach(
								function( vertex ) {
									for ( var i = 0 ; i < vertex.value.length ; i++ ) {
										var v = vertex.value[ i ][ 0 ];
										if ( EPSILON == range.min[ i ] || v < range.min[ i ] ) range.min[ i ] = v;
										if ( EPSILON == range.max[ i ] || v > range.max[ i ] ) range.max[ i ] = v;
									}
								}
							);

							for ( var i = 0 ; i < range.diff.length ; i++ ) {
								range.diff[ i ] = range.max[ i ] - range.min[ i ];
							}

							side.forEach(
								function( vertex ) {
									for ( var i = 0 ; i < range.diff.length ; i++ ) {
										if ( !range.diff[ i ] ) continue;
										var v = vertex.value[ i ][ 0 ];
										v = ( v - range.min[ i ] ) / range.diff[ i ];
										if ( 's' in vertex ) {
											vertex.t = v * 255;
										} else {
											vertex.s = v * 255;
										}
									}
								}
							);
						}
					);
					return sides;
				};
				
				const midpoint = function( p1, p2 ) {
					var middle = new Point().tween( p1, p2, 0.5 );
					middle.s = p1.s + ( p2.s - p1.s ) * 0.5;
					middle.t = p1.t + ( p2.t - p1.t ) * 0.5;
					return middle;
				};

				const splitSide = function( side, sides ) {
					var middle1 = midpoint( side[ 0 ], side[ 1 ] );
					var middle2 = midpoint( side[ 1 ], side[ 2 ] );
					var middle3 = midpoint( side[ 2 ], side[ 3 ] );
					var middle0 = midpoint( side[ 3 ], side[ 0 ] );
					var middleX = midpoint( middle0, middle2 );

					// these are backwards (clockwise) like the geom files
					sides.push( [ middle0, side[ 0 ], middle1, middleX ] );
					sides.push( [ middleX, middle1, side[ 1 ], middle2 ] );
					sides.push( [ side[ 3 ], middle0, middleX, middle3 ] );
					sides.push( [ middle3, middleX, middle2, side[ 2 ] ] );
				};

				const splitSides = function( sides, splits ) {
					for ( var i = 0 ; i < splits ; i++ ) {
						var tmp = [];
						sides.forEach(
							function( side ) {
								splitSide( side, tmp );
							}
						);
						sides = tmp;
					}
					return sides;
				};

				var sides = splitSides( makeSides(), 3 );

				const toColor = function( v ) {
					return Math.floor( ( v + 1 ) / 2.0 * 255 ) % 255;
				};

				const makePoint = function( pt, original ) {
					var x = pt[ 0 ][ 0 ];
					var y = pt[ 1 ][ 0 ];
					var z = pt[ 2 ][ 0 ];
					
					var tmp = spherish;
					if ( tmp > 1 ) tmp = 1;
					if ( tmp < 0 ) tmp = 0;
					var xxx = 1.0 - tmp;

					var sz = Math.sqrt( x * x + y * y + z * z );
					x = ( x / sz * tmp ) + ( x * xxx );
					y = ( y / sz * tmp ) + ( y * xxx );
					z = ( z / sz * tmp ) + ( z * xxx );

					var px = Math.floor( w2 + x * w3 );
					var py = Math.floor( w2 + y * w3 );

					return {
						  x:px
						, y:py
						, z:z
						, r:original.s
						, g:original.t
						, b:tb6.texture ? -1 : 255 - original.s
						, rx:x
						, ry:y
						, rz:z
					};
				};

				const triangle = function( rotations, p1, p2, p3 ) {
					//console.log( 'p1:' + JSON.stringify( p1 ) );

					var t1 = matrix.multiply( rotations, p1.value );
					var t2 = matrix.multiply( rotations, p2.value );
					var t3 = matrix.multiply( rotations, p3.value );

					var pt1 = makePoint( t1, p1 );
					var pt2 = makePoint( t2, p2 );
					var pt3 = makePoint( t3, p3 );

					var n1 = new Point().initXYZ( pt1.rx, pt1.ry, pt1.rz );
					var n2 = new Point().initXYZ( pt2.rx, pt2.ry, pt2.rz );
					var n3 = new Point().initXYZ( pt3.rx, pt3.ry, pt3.rz );

					var normal = false;
					if ( useShading ) {
						normal = new Point().cross( n1.minus( n2 ), n3.minus( n2 ) ).normalize();
						normal = normal.toXYZ();

						if ( normal.z < 0 ) {
							return;
						}
					} 

					tb6.triangleDraw( pt1, pt2, pt3, normal );
				};

				const comma = function( n ) {
					return ( '' + n ).replace( /\d{1,3}(?=(\d{3})+(?!\d))/g, '$&,' );
				};

				const nextFrame = function( cb ) {
					setTimeout(
						function() {
							requestAnimationFrame( cb );
						}, 1000 / 64
					);
				};

				const drawWrapper = function() {
					var start = new Date().getTime() / 1000.0;

					tb6.clear();

					var rotations = matrix.makeRotations( angles[ 0 ], angles[ 1 ], angles[ 2 ] );

					if ( paused ) {
						tb6.context.fillStyle = 'black';
						var message = 'paused at: angles = ' + JSON.stringify( angles );
						tb6.context.fillText( message, 13, 13 );
						info.innerHTML = message;
					} else {
						angles[ which ] += angle_increment;


						control[ which ].ignore = true;
						control[ which ].value = Math.floor( 
							1000 * ( angles[ which ] / ( Math.PI * 2 ) )
						) % 1000;
						control[ which ].ignore = false;

						spherish += spherish_increment;
						if ( spherish > 2 ) {
							spherish = 1;
							spherish_increment *= -1;
						} else {
							if ( spherish < -1 ) {
								spherish = 0;
								spherish_increment *= -1;
							}
						}
					}

					if ( 0 == ++iteration % 44 ) which = ( which + 1 ) % 3;

					if ( 0 == iteration % 33 ) {
						var tps = comma( Math.floor( triangles / time ) );
						var trz = comma( triangles );
						var secz = comma( Math.floor( time * 10 )  / 10.0 );
						var overall = comma( Math.floor( ( start - begin ) * 10 ) / 10.0 );
						info.innerHTML = ( ''
							+ tps + ' triangles per second<br/>' 
							+ trz + ' triangles in ' + secz + ' seconds drawing<br/>' 
							+ overall + ' seconds total'
						);
						console.log( info.innerHTML );
					}

					sides.forEach(
						function( side ) {
							triangle( rotations, side[ 0 ], side[ 1 ], side[ 3 ] );
							triangle( rotations, side[ 3 ], side[ 1 ], side[ 2 ] );
							triangles += 2;
						}
					);

					tb6.flush();

					if ( useTextures ) {
						if ( useDynamicTextures || !tb6.texture ) { 
							if ( useDynamicTextures ) {
								var imageData = tb6.context.getImageData( 0, 0, w, h );
								tb6.setTexture( imageData.data, w, h );
							} else {
								var image = document.getElementsByTagName( 'img' )[ 0 ];
								tb6.context.drawImage( image, 0, 0 );

								var imageData = tb6.context.getImageData( 0, 0, 256, 256 );
								tb6.setTexture( imageData.data, 256, 256 );
					
								tb6.flush();
							}
						}
					} else {
						if ( tb6.texture ) {
							tb6.setTexture( null, 0, 0 );
							console.log( 'go away...' );
						}
					}

					var end = new Date().getTime() / 1000.0;
					time += ( end - start );

					return nextFrame( drawWrapper );
				};
				drawWrapper();
			}
		</script>
	</HEAD>
	<BODY>
		<canvas width="512" height="512"></canvas>
		<div>
			<input type="checkbox" checked="ww" id="texture"/>  texture
			<input type="checkbox" ichecked="ww" id="dynamic"/>  dynamic texture
			<input type="checkbox" ichecked="ww" id="outlines"/> outlines
			<input type="checkbox" checked="ww" id="shading"/>  shading
			<input type="color" id="background" value="#9090F0"/> background
			<button id="timer">reset timer</button>
			<button id="alphonzo">alphonzo</button>
		</div>
		<div>
			<input id="a0" type="range" min="0" max="1000" step="1"/>
			<input id="a1" type="range" min="0" max="1000" step="1"/>
			<input id="a2" type="range" min="0" max="1000" step="1"/>
		</div>
		<div id="info">u&lt;3 it!</div>
		<img src="images/water-texture.jpg"></img>
	</BODY>
</HTML>
